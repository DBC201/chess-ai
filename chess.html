<!DOCTYPE html>
<html>

<head>
	<link rel="stylesheet" href="./public/chessboard2.min.css">
	<script src="./public/chessboard2.min.js"></script>

	<script src="./public/chess.min.js"></script>

	<style>
		.button_class {
			width: 75px;
			height: 30px;
			margin: 15px;
		}
	</style>
</head>

<body style="text-align: center;">

	<div id="myBoard" style="width: 600px; margin: 0 auto; margin-top: 75px;"></div>
	<br>
	<br>
	<button class="button_class" id="start" onclick="start()">start</button>
	<button class="button_class" id="stop" onclick="stop()">stop</button>
	<button class="button_class" id="reset" onclick="reset()">reset</button>
	<br>
	<br>
	<button class="button_class" id="undo" onclick="undo()">Undo</button>
	<br>
	<br>
	<label for="speed">Speed:</label>
	<input type="number" id="speed" value="500" style="width: 75px; height: 30px; margin: 15px;">
	<br>
	<br>
	<label for="white_depth">White depth:</label>
	<input type="number" id="white_depth" value="2" style="width: 75px; height: 30px; margin: 15px;">
	<br>
	<br>
	<label for="black_depth">Black depth:</label>
	<input type="number" id="black_depth" value="2" style="width: 75px; height: 30px; margin: 15px;">
	<br>
	<br>
	<label for="debug">Debug mode(stop after one move and print debug info to console):</label> <br><input type="checkbox" id="debug">
	<br>
	<br>
	<label for="fen">Enter fen and press reset(blank for start):</label>
	<br>
	<br>
	<textarea id="fen" style="width: 400px; height: 100px"></textarea>
	<br>
	<br>
	<p id="pgn"></p>
	<script>
		const game = new Chess();
		const board = Chessboard2('myBoard', {
			draggable: false,
			position: 'start',
			// onDragStart,
			// onDrop,
			// onMouseoutSquare,
			// onMouseoverSquare,
			// onSnapEnd
		});

		function onDrop({ source, target, piece, orientation }) {
			console.log('Source: ' + source)
			console.log('Target: ' + target)
			console.log('Piece: ' + piece);
			game.move({ from: source, to: target });
			console.log(game.moves({ verbose: true }));
		}

		function getRandom(list) {
			return list[Math.floor(Math.random() * list.length)];
		}

		function getRandomMove(game) {
			return getRandom(game.moves());
		}

		class Node {
			constructor(game) {
				this.parent = null;
				this.children = [];
				this.score = null;

				this.uncalculatedCount = 0;

				this.game = new Chess(game.fen());

				this.depth = 0;

				this.pieceValues = {
					'p': 1, 'n': 3, 'b': 3.25, 'r': 5, 'q': 8, 'k': 0
				};
			}

			addParent(parent) {
				this.parent = parent;
				parent.children.push(this);
				if (this.score === null) {
					parent.uncalculatedCount++;
				}
				this.depth = parent.depth + 1;
			}

			getHistory() {
				const history = [];
				let node = this;

				while (node && node.game.history().length) {
					history.unshift(node.game.history()[0]);
					node = node.parent;
				}

				return history;
			}

			calculate() {
				if (this.score !== null) {
					return;
				}

				if (this.game.in_checkmate()) {
					this.score = this.game.turn() === 'b' ? Infinity : -Infinity;
				} else if (this.game.in_draw()) {
					this.score = 0;
				}
				else {
					this.score = 0;

					const board = this.game.board();
					for (let i = 0; i < board.length; i++) {
						for (let j = 0; j < board.length; j++) {
							const square = board[i][j];

							if (!square) {
								continue;
							}

							if (square.color === 'w') {
								this.score += this.pieceValues[square.type];
							}
							else if (square.color === 'b') {
								this.score -= this.pieceValues[square.type];
							}
						}
					}
				}

				let node = this;

				while (node && node.uncalculatedCount === 0) {
					if (node.parent) {
						node.parent.uncalculatedCount--;
						if (node.parent.score === null) {
							node.parent.score = node.score;
						} else if (node.parent.game.turn() === 'w') {
							node.parent.score = Math.max(node.parent.score, node.score);
						} else {
							node.parent.score = Math.min(node.parent.score, node.score);
						}
					}

					node = node.parent;
				}
			}
		}

		function getCalculations(game, max_depth) {
			if (max_depth <= 0) {
				return getRandomMove(game);
			}
			if (game.moves() < 8) {
				
			}

			const q = [];

			const root = new Node(game);

			q.push(root);

			while (q.length) {
				const curr = q.shift();

				if (curr.depth >= max_depth || curr.game.game_over()) {
					let node = curr;
					node.calculate();
					continue;
				}

				const moves = curr.game.moves();
				for (let i=0; i<moves.length; i++) {
					const node = new Node(curr.game);
					node.game.move(moves[i]);
					node.addParent(curr);
					q.push(node);
				}
			}

			root.children.sort((a, b) => a.score - b.score);

			return root;
		}

		let cache = null;

		function getBestMove(game, max_depth) {
			let root;

			if (cache) {
				root = cache;
			}
			else {
				root = getCalculations(game, max_depth);
			}

			if (document.getElementById('debug').checked) {
				for (let i=0; i<root.children.length; i++) {
					console.log(root.children[i].score, root.children[i].game.history()[0]);
					root.children[i].children.forEach((node) => console.log('\t', node.game.history()[0], node.score));
				}
			}

			const next = getRandom(root.children.filter((child) => child.score === root.score));

			if (root.score === Infinity || root.score === -Infinity) {
				cache = next; // cache only if win or lose
			}

			return next.game.history()[0];
		}

		let stop_flag = false;
		let in_progress = false;

		function play() {
			if (stop_flag) {
				document.getElementById('pgn').innerText = game.pgn();
				document.getElementById("start").disabled = false;
				document.getElementById("undo").disabled = false;
				return;
			}

			if (game.game_over()) {
				stop_flag = true;
				document.getElementById('pgn').innerText = game.pgn();
				return;
			}

			let nextMove;
			let start;

			if (document.getElementById('debug').checked) {
				start = performance.now();
			}
			
			if (game.turn() == 'b') {
				nextMove = getBestMove(game, document.getElementById('black_depth').value);
			} else {
				nextMove = getBestMove(game, document.getElementById('white_depth').value);
			}

			if (document.getElementById('debug').checked) {
				console.log('Time taken: ', performance.now() - start);
				stop_flag = true;
			}

			game.move(nextMove);
			board.position(game.fen());
			setTimeout(play, document.getElementById('speed').value);
		}

		function start() {
			stop_flag = false;
			document.getElementById("start").disabled = true;
			document.getElementById("undo").disabled = true;
			play();
		}

		function stop() {
			document.getElementById('pgn').innerText = game.pgn();
			document.getElementById("start").disabled = false;
			document.getElementById("undo").disabled = false;
			stop_flag = true;
		}
		
		function undo() {
			game.undo();
			board.position(game.fen());
		}

		function reset() {
			game.reset();
			const fen = document.getElementById('fen').value;
			if (fen) {
				game.load(fen);
			}
			board.position(game.fen());
		}
	</script>

</body>

</html>